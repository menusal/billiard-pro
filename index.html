<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Carambola Master Pro</title>
    
    <!-- Configuración PWA y Móvil -->
    <meta name="theme-color" content="#020617">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="CarambolaPro">
    <link rel="apple-touch-icon" href="https://cdn-icons-png.flaticon.com/512/3254/3254934.png">
    <link id="manifest-link" rel="manifest">

    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #020617;
            font-family: 'Segoe UI', system-ui, sans-serif;
            touch-action: none;
            user-select: none;
            display: flex;
            align-items: center;
            justify-content: center;
            min-h-screen;
        }
        
        #game-layout {
            display: flex;
            flex-direction: row;
            width: 100vw;
            height: 100vh;
            background-color: #020617;
        }

        #table-area {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            padding: 10px;
        }

        #sidebar {
            width: 140px;
            background: rgba(15, 23, 42, 0.95);
            backdrop-filter: blur(10px);
            border-left: 1px solid rgba(255,255,255,0.1);
            display: flex;
            flex-direction: column;
            padding: 15px 10px;
            gap: 10px;
            z-index: 20;
            justify-content: space-between;
        }

        canvas {
            box-shadow: 0 25px 60px rgba(0,0,0,1);
            border: 10px solid #1e1b18;
            border-radius: 6px;
            background-color: #064e3b;
            max-width: 100%;
            max-height: 100%;
        }

        .ball-selector {
            width: 130px;
            height: 130px;
            border-radius: 50%;
            background: radial-gradient(circle at 35% 35%, #ffffff, #cbd5e1);
            position: relative;
            cursor: crosshair;
            box-shadow: inset -6px -6px 20px rgba(0,0,0,0.2), 0 15px 30px rgba(0,0,0,0.5);
            border: 2px solid rgba(255,255,255,0.2);
        }

        #impact-dot {
            width: 12px;
            height: 12px;
            background: #ef4444;
            border: 2px solid white;
            border-radius: 50%;
            position: absolute;
            transform: translate(-50%, -50%);
            pointer-events: none;
            box-shadow: 0 0 10px rgba(239, 68, 68, 0.8);
        }

        .active-turn {
            border-color: #10b981 !important;
            box-shadow: 0 0 15px rgba(16, 185, 129, 0.3);
            transform: scale(1.02);
        }

        .crosshair-h { position: absolute; top: 50%; left: 0; width: 100%; height: 1px; background: rgba(0,0,0,0.1); pointer-events: none; }
        .crosshair-v { position: absolute; left: 50%; top: 0; width: 1px; height: 100%; background: rgba(0,0,0,0.1); pointer-events: none; }

        @media (orientation: portrait) {
            #game-layout { flex-direction: column; }
            #sidebar { width: 100%; height: auto; flex-direction: row; border-left: none; border-top: 1px solid rgba(255,255,255,0.1); }
        }
    </style>
</head>
<body>

    <!-- Pantalla Inicial (Menú) -->
    <div id="start-screen" class="fixed inset-0 z-50 bg-slate-950 flex flex-col items-center justify-center p-6 text-center">
        <div class="mb-12">
            <h1 class="text-white text-5xl font-black italic tracking-tighter mb-2 uppercase">Carambola <span class="text-emerald-500">Pro</span></h1>
            <p class="text-white/40 text-xs uppercase tracking-[0.3em]">Simulador de Alta Precisión</p>
        </div>
        
        <div class="space-y-4 w-full max-w-xs">
            <button id="start-match-btn" class="w-full py-5 bg-gradient-to-br from-emerald-400 to-emerald-700 text-white font-black uppercase tracking-widest rounded-2xl shadow-2xl shadow-emerald-500/20 active:scale-95 transition-all">
                Iniciar Partida
            </button>
            <p class="text-white/20 text-[10px] uppercase">Dos Jugadores · Lateral UI · PWA</p>
        </div>
    </div>

    <!-- Layout de Juego Principal -->
    <div id="game-layout" class="hidden">
        <!-- Area de la Mesa (Izquierda) -->
        <div id="table-area">
            <canvas id="poolTable"></canvas>
        </div>

        <!-- Barra Lateral de Información (Derecha) -->
        <aside id="sidebar">
            <div class="flex flex-col gap-4">
                <!-- Marcador J1 -->
                <div id="p1-panel" class="bg-black/60 p-2 rounded-xl border border-white/10 text-white transition-all active-turn">
                    <div class="flex items-center gap-1.5 mb-0.5">
                        <div class="w-2 h-2 rounded-full bg-white"></div>
                        <p class="text-[8px] uppercase tracking-wider font-bold">J1</p>
                    </div>
                    <p id="score1" class="text-2xl font-black italic text-center leading-none">0</p>
                </div>

                <!-- Marcador J2 -->
                <div id="p2-panel" class="bg-black/60 p-2 rounded-xl border border-white/10 text-white transition-all">
                    <div class="flex items-center gap-1.5 mb-0.5">
                        <div class="w-2 h-2 rounded-full bg-yellow-400"></div>
                        <p class="text-[8px] uppercase tracking-wider font-bold">J2</p>
                    </div>
                    <p id="score2" class="text-2xl font-black italic text-center leading-none">0</p>
                </div>
            </div>

            <div class="flex flex-col gap-3 items-center">
                <!-- Estado del Juego -->
                <div id="state-indicator" class="bg-emerald-500/20 px-3 py-2 rounded-xl border border-emerald-500/30 text-emerald-400 text-[8px] font-black uppercase text-center leading-tight">
                    Turno J1
                </div>

                <!-- Botones de Acción -->
                <div class="flex flex-col gap-2 w-full">
                    <button id="audio-toggle" class="bg-white/5 hover:bg-white/10 text-white py-2 rounded-xl border border-white/10 flex justify-center items-center transition-colors">
                        <svg id="audio-icon" xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="currentColor" viewBox="0 0 16 16">
                            <path d="M6.717 3.55A.5.5 0 0 1 7 4v8a.5.5 0 0 1-.812.39L3.825 10.5H1.5A.5.5 0 0 1 1 10V6a.5.5 0 0 1 .5-.5h2.325l2.363-1.89a.5.5 0 0 1 .529-.06zM6 5.04L4.312 6.39A.5.5 0 0 1 4 6.5H2v3h2a.5.5 0 0 1 .312.11L6 10.96V5.04z"/>
                            <path d="M11.536 14.01A8.473 8.473 0 0 0 14.026 8a8.473 8.473 0 0 0-2.49-6.01l-.708.707A7.476 7.476 0 0 1 13.025 8c0 2.071-.84 3.946-2.197 5.303l.708.707z"/>
                        </svg>
                    </button>
                    <button id="reset-btn" class="bg-red-500/10 hover:bg-red-500/20 text-red-400 py-2 rounded-xl border border-red-500/20 text-[9px] font-bold uppercase tracking-widest transition-all">
                        Reset
                    </button>
                </div>
            </div>
        </aside>
    </div>

    <!-- Selector de Efecto -->
    <div id="spin-modal" class="hidden fixed inset-0 bg-slate-950/95 backdrop-blur-md z-40 flex flex-col items-center justify-center">
        <div class="bg-slate-900 p-8 rounded-[2.5rem] border border-white/10 flex flex-col items-center shadow-2xl scale-110">
            <h3 class="text-white text-[10px] font-black mb-6 uppercase tracking-[0.3em] opacity-70 italic text-center">
                Punto de contacto<br><span id="spin-ball-name" class="text-emerald-400">Bola Blanca</span>
            </h3>
            
            <div class="ball-selector" id="ball-ui">
                <div class="crosshair-h"></div>
                <div class="crosshair-v"></div>
                <div id="impact-dot" style="top: 50%; left: 50%;"></div>
            </div>

            <div class="mt-8 flex gap-4 w-full">
                <button id="cancel-btn" class="flex-1 py-4 bg-white/5 text-white/70 rounded-2xl text-[10px] font-black uppercase tracking-widest border border-white/5">Atrás</button>
                <button id="shoot-btn" class="flex-1 py-4 bg-gradient-to-br from-orange-400 to-red-600 text-white rounded-2xl text-[10px] font-black uppercase tracking-widest shadow-xl active:scale-95 transition-all">¡Golpear!</button>
            </div>
        </div>
    </div>

    <script>
        /**
         * MOTOR DE SONIDO
         */
        const SoundEngine = {
            ctx: null, enabled: false,
            init() { if (this.ctx) return; this.ctx = new (window.AudioContext || window.webkitAudioContext)(); this.enabled = true; },
            toggle() { if (!this.ctx) this.init(); this.enabled = !this.enabled; return this.enabled; },
            playClick(volume = 1) {
                if (!this.enabled || !this.ctx) return;
                const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain();
                osc.type = 'sine'; osc.frequency.setValueAtTime(800, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(100, this.ctx.currentTime + 0.05);
                gain.gain.setValueAtTime(volume * 0.2, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.05);
                osc.connect(gain); gain.connect(this.ctx.destination); osc.start(); osc.stop(this.ctx.currentTime + 0.05);
            },
            playThud(volume = 1) {
                if (!this.enabled || !this.ctx) return;
                const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain();
                osc.type = 'triangle'; osc.frequency.setValueAtTime(150, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(40, this.ctx.currentTime + 0.1);
                gain.gain.setValueAtTime(volume * 0.3, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.1);
                osc.connect(gain); gain.connect(this.ctx.destination); osc.start(); osc.stop(this.ctx.currentTime + 0.1);
            },
            playCue(v = 1) {
                if (!this.enabled || !this.ctx) return;
                const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain();
                osc.type = 'sine'; osc.frequency.setValueAtTime(400, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(200, this.ctx.currentTime + 0.1);
                gain.gain.setValueAtTime(v * 0.2, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.1);
                osc.connect(gain); gain.connect(this.ctx.destination); osc.start(); osc.stop(this.ctx.currentTime + 0.1);
            },
            playSuccess() {
                if (!this.enabled || !this.ctx) return;
                [523, 659, 783].forEach((f, i) => {
                    const o = this.ctx.createOscillator(); const g = this.ctx.createGain();
                    o.frequency.setValueAtTime(f, this.ctx.currentTime + i*0.1);
                    g.gain.setValueAtTime(0, this.ctx.currentTime + i*0.1);
                    g.gain.linearRampToValueAtTime(0.1, this.ctx.currentTime + i*0.1 + 0.05);
                    g.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + i*0.1 + 0.5);
                    o.connect(g); g.connect(this.ctx.destination); o.start(this.ctx.currentTime + i*0.1); o.stop(this.ctx.currentTime + i*0.1 + 0.5);
                });
            },
            playFail() {
                if (!this.enabled || !this.ctx) return;
                const o = this.ctx.createOscillator(); const g = this.ctx.createGain();
                o.frequency.setValueAtTime(200, this.ctx.currentTime);
                o.frequency.linearRampToValueAtTime(100, this.ctx.currentTime + 0.3);
                g.gain.setValueAtTime(0.2, this.ctx.currentTime);
                g.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.3);
                o.connect(g); g.connect(this.ctx.destination); o.start(); o.stop(this.ctx.currentTime + 0.3);
            }
        };

        const canvas = document.getElementById('poolTable');
        const ctx = canvas.getContext('2d');
        const score1Element = document.getElementById('score1');
        const score2Element = document.getElementById('score2');
        const p1Panel = document.getElementById('p1-panel');
        const p2Panel = document.getElementById('p2-panel');
        const stateIndicator = document.getElementById('state-indicator');
        const spinModal = document.getElementById('spin-modal');
        const ballUI = document.getElementById('ball-ui');
        const impactDot = document.getElementById('impact-dot');
        const spinBallName = document.getElementById('spin-ball-name');
        const startScreen = document.getElementById('start-screen');
        const gameLayout = document.getElementById('game-layout');

        let width, height;
        let balls = [];
        let currentPlayer = 1;
        let scores = { p1: 0, p2: 0 };
        let gameState = 'AIMING'; 
        let appState = 'MENU'; 
        
        let currentShot = { power: 0, angle: 0, spinX: 0, spinY: 0 };
        let isDragging = false;
        let dragStart = { x: 0, y: 0 };
        let dragEnd = { x: 0, y: 0 };

        const FRICTION = 0.9975;
        const WALL_BOUNCE = 0.82;
        const BALL_BOUNCE = 0.98;
        const MIN_VEL = 0.02;
        const SPIN_FRICTION = 0.985;
        const BALL_RADIUS = 14;

        class Ball {
            constructor(x, y, color, label) {
                this.x = x; this.y = y; this.vx = 0; this.vy = 0;
                this.color = color; this.label = label;
                this.radius = BALL_RADIUS; this.spinX = 0; this.spinY = 0; 
            }
            draw() {
                ctx.save();
                ctx.shadowBlur = 12; ctx.shadowColor = 'rgba(0,0,0,0.4)';
                ctx.shadowOffsetX = 4; ctx.shadowOffsetY = 4;
                ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                const grad = ctx.createRadialGradient(this.x - 5, this.y - 5, 2, this.x, this.y, this.radius);
                grad.addColorStop(0, '#ffffff'); grad.addColorStop(0.3, this.color); grad.addColorStop(1, this.color);
                ctx.fillStyle = grad; ctx.fill(); ctx.restore();
                ctx.beginPath(); ctx.arc(this.x - 4, this.y - 4, 3, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255,255,255,0.3)'; ctx.fill();
            }
            update() {
                if (appState !== 'PLAYING') return;
                this.x += this.vx; this.y += this.vy;
                this.vx *= FRICTION; this.vy *= FRICTION;
                if ((currentPlayer === 1 && this.label === 'white') || (currentPlayer === 2 && this.label === 'yellow')) {
                    this.vx += this.spinX * 0.006; this.spinX *= SPIN_FRICTION; this.spinY *= SPIN_FRICTION;
                }
                if (Math.abs(this.vx) < MIN_VEL && Math.abs(this.vy) < MIN_VEL) { this.vx = 0; this.vy = 0; }
                const spinStrength = 7.5;
                let hitWall = false;
                if (this.x - this.radius < 0) { this.vx *= -WALL_BOUNCE; if (this.spinX !== 0) this.vy -= this.spinX * spinStrength; this.x = this.radius; this.spinX *= 0.6; hitWall = true; } 
                else if (this.x + this.radius > width) { this.vx *= -WALL_BOUNCE; if (this.spinX !== 0) this.vy += this.spinX * spinStrength; this.x = width - this.radius; this.spinX *= 0.6; hitWall = true; }
                if (this.y - this.radius < 0) { this.vy *= -WALL_BOUNCE; if (this.spinX !== 0) this.vx += this.spinX * spinStrength; this.y = this.radius; this.spinX *= 0.6; hitWall = true; } 
                else if (this.y + this.radius > height) { this.vy *= -WALL_BOUNCE; if (this.spinX !== 0) this.vx -= this.spinX * spinStrength; this.y = height - this.radius; this.spinX *= 0.6; hitWall = true; }
                if (hitWall) SoundEngine.playThud(Math.min(Math.sqrt(this.vx**2 + this.vy**2) / 5, 1));
            }
        }

        function init() {
            // MÁXIMO TAMAÑO DISPONIBLE
            const sidebarWidth = (window.innerWidth > window.innerHeight) ? 140 : 0;
            const tableArea = document.getElementById('table-area').getBoundingClientRect();
            
            const availableHeight = tableArea.height - 20;
            const availableWidth = tableArea.width - 20;

            height = availableHeight;
            width = Math.min(availableWidth, height * 1.9); // Ratio 1.9

            canvas.width = width;
            canvas.height = height;

            balls = [
                new Ball(width * 0.2, height * 0.5, '#ffffff', 'white'),
                new Ball(width * 0.4, height * 0.45, '#facc15', 'yellow'),
                new Ball(width * 0.8, height * 0.5, '#ef4444', 'red')
            ];
            
            requestAnimationFrame(gameLoop);
        }

        let hits = { white: false, yellow: false, red: false };

        function resolveCollisions() {
            for (let i = 0; i < balls.length; i++) {
                for (let j = i + 1; j < balls.length; j++) {
                    const b1 = balls[i]; const b2 = balls[j];
                    const dx = b2.x - b1.x; const dy = b2.y - b1.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < b1.radius + b2.radius) {
                        const cueLabel = (currentPlayer === 1) ? 'white' : 'yellow';
                        if (b1.label === cueLabel) hits[b2.label] = true;
                        else if (b2.label === cueLabel) hits[b1.label] = true;
                        const effectInt = 1.2;
                        if (b1.label === cueLabel) {
                            const v = Math.sqrt(b1.vx**2 + b1.vy**2);
                            const p = b1.spinY * effectInt * (v * 0.8);
                            b1.vx += (dx / dist) * p; b1.vy += (dy / dist) * p;
                        } else if (b2.label === cueLabel) {
                            const v = Math.sqrt(b2.vx**2 + b2.vy**2);
                            const p = b2.spinY * effectInt * (v * 0.8);
                            b2.vx -= (dx / dist) * p; b2.vy -= (dy / dist) * p;
                        }
                        const relativeVel = Math.sqrt((b1.vx - b2.vx)**2 + (b1.vy - b2.vy)**2);
                        SoundEngine.playClick(Math.min(relativeVel / 10 + 0.2, 1));
                        const overlap = b1.radius + b2.radius - dist;
                        const nx = dx / dist; const ny = dy / dist;
                        b1.x -= nx * overlap / 2; b1.y -= ny * overlap / 2;
                        b2.x += nx * overlap / 2; b2.y += ny * overlap / 2;
                        const v1n = b1.vx * nx + b1.vy * ny; const v2n = b2.vx * nx + b2.vy * ny;
                        const v1t = -b1.vx * ny + b1.vy * nx; const v2t = -b2.vx * ny + b2.vy * nx;
                        b1.vx = (v2n * BALL_BOUNCE) * nx - v1t * ny; b1.vy = (v2n * BALL_BOUNCE) * ny + v1t * nx;
                        b2.vx = (v1n * BALL_BOUNCE) * nx - v2t * ny; b2.vy = (v1n * BALL_BOUNCE) * ny + v2t * nx;
                    }
                }
            }
        }

        function drawPredictivePath(startX, startY, angle, power) {
            let currentX = startX; let currentY = startY;
            let currentVX = Math.cos(angle); let currentVY = Math.sin(angle);
            let remainingDist = power * 15; let maxBounces = 4; let bounces = 0;
            const cueLabel = (currentPlayer === 1) ? 'white' : 'yellow';
            ctx.beginPath(); ctx.setLineDash([4, 4]); ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)'; ctx.moveTo(currentX, currentY);
            while (remainingDist > 0 && bounces < maxBounces) {
                let tWX = Infinity, tWY = Infinity;
                if (currentVX > 0) tWX = (width - BALL_RADIUS - currentX) / currentVX; else if (currentVX < 0) tWX = (BALL_RADIUS - currentX) / currentVX;
                if (currentVY > 0) tWY = (height - BALL_RADIUS - currentY) / currentVY; else if (currentVY < 0) tWY = (BALL_RADIUS - currentY) / currentVY;
                let tWall = Math.min(tWX, tWY); let tBall = Infinity; let target = null;
                for (let b of balls) {
                    if (b.label === cueLabel) continue;
                    const dx = b.x - currentX; const dy = b.y - currentY;
                    const dot = dx * currentVX + dy * currentVY;
                    if (dot > 0) {
                        const d2 = dx*dx + dy*dy - dot*dot; const r2 = (BALL_RADIUS * 2) ** 2;
                        if (d2 < r2) { const t = dot - Math.sqrt(r2 - d2); if (t > 0.1 && t < tBall) { tBall = t; target = b; } }
                    }
                }
                let tMin = Math.min(tWall, tBall);
                if (tMin > remainingDist) { ctx.lineTo(currentX + currentVX * remainingDist, currentY + currentVY * remainingDist); remainingDist = 0; } 
                else {
                    currentX += currentVX * tMin; currentY += currentVY * tMin; ctx.lineTo(currentX, currentY); remainingDist -= tMin;
                    if (tBall < tWall) {
                        const nx = (currentX - target.x) / (BALL_RADIUS * 2); const ny = (currentY - target.y) / (BALL_RADIUS * 2);
                        const dot = currentVX * nx + currentVY * ny; currentVX -= 2 * dot * nx; currentVY -= 2 * dot * ny;
                    } else { if (tMin === tWX) currentVX *= -1; else currentVY *= -1; }
                    bounces++;
                }
            }
            ctx.stroke(); ctx.setLineDash([]);
        }

        function gameLoop() {
            ctx.clearRect(0, 0, width, height);
            if (appState === 'PLAYING') {
                ctx.fillStyle = '#064e3b'; ctx.fillRect(0, 0, width, height);
                ctx.fillStyle = 'rgba(255,255,255,0.2)';
                for(let i=1; i<8; i++) {
                    ctx.beginPath(); ctx.arc((width/8)*i, 6, 2, 0, Math.PI*2); ctx.fill();
                    ctx.beginPath(); ctx.arc((width/8)*i, height-6, 2, 0, Math.PI*2); ctx.fill();
                }
                resolveCollisions();
                let moving = false;
                balls.forEach(ball => { ball.update(); ball.draw(); if (ball.vx !== 0 || ball.vy !== 0) moving = true; });
                if (gameState === 'ANIMATING' && !moving) { gameState = 'CHECKING'; checkResult(); }
                if (gameState === 'AIMING' && isDragging) {
                    const cue = balls.find(b => b.label === (currentPlayer === 1 ? 'white' : 'yellow'));
                    const dx = dragStart.x - dragEnd.x; const dy = dragStart.y - dragEnd.y;
                    const dist = Math.min(Math.sqrt(dx*dx + dy*dy), 220); const angle = Math.atan2(dy, dx);
                    drawPredictivePath(cue.x, cue.y, angle, dist * 0.17);
                    ctx.beginPath(); ctx.lineWidth = 6; ctx.lineCap = 'round';
                    ctx.moveTo(cue.x - Math.cos(angle) * 30, cue.y - Math.sin(angle) * 30);
                    ctx.lineTo(cue.x - Math.cos(angle) * (30 + dist), cue.y - Math.sin(angle) * (30 + dist));
                    ctx.strokeStyle = 'rgba(255,255,255,0.15)'; ctx.stroke();
                }
            }
            requestAnimationFrame(gameLoop);
        }

        function checkResult() {
            let carom = (currentPlayer === 1) ? (hits.yellow && hits.red) : (hits.white && hits.red);
            if (carom) {
                if (currentPlayer === 1) { scores.p1++; score1Element.innerText = scores.p1; } 
                else { scores.p2++; score2Element.innerText = scores.p2; }
                SoundEngine.playSuccess();
                stateIndicator.innerText = "¡CARAMBOLA! J" + currentPlayer + " repite";
                stateIndicator.className = "bg-yellow-500 text-black px-3 py-2 rounded-xl border border-yellow-200 text-[8px] font-black uppercase shadow-lg animate-bounce";
            } else {
                SoundEngine.playFail();
                currentPlayer = (currentPlayer === 1) ? 2 : 1;
                stateIndicator.innerText = "Fallo. Turno J" + currentPlayer;
                stateIndicator.className = "bg-red-500 text-white px-3 py-2 rounded-xl border border-red-300 text-[8px] font-black uppercase shadow-lg";
                p1Panel.className = (currentPlayer === 1) ? "bg-black/60 p-2 rounded-xl border border-white/10 text-white transition-all active-turn" : "bg-black/60 p-2 rounded-xl border border-white/10 text-white transition-all";
                p2Panel.className = (currentPlayer === 2) ? "bg-black/60 p-2 rounded-xl border border-white/10 text-white transition-all active-turn" : "bg-black/60 p-2 rounded-xl border border-white/10 text-white transition-all";
            }
            setTimeout(() => {
                if (appState !== 'PLAYING') return;
                gameState = 'AIMING';
                stateIndicator.innerText = "Turno J" + currentPlayer;
                stateIndicator.className = "bg-emerald-500/20 text-emerald-400 px-3 py-2 rounded-xl border border-emerald-500/30 text-[8px] font-black uppercase shadow-lg";
                hits = { white: false, yellow: false, red: false };
            }, 1800);
        }

        function startGame() {
            SoundEngine.init(); startScreen.classList.add('hidden'); gameLayout.classList.remove('hidden');
            appState = 'PLAYING'; init(); resetMatch();
        }
        function resetToMenu() { startScreen.classList.remove('hidden'); gameLayout.classList.add('hidden'); appState = 'MENU'; }
        function resetMatch() {
            scores = { p1: 0, p2: 0 }; score1Element.innerText = 0; score2Element.innerText = 0;
            currentPlayer = 1; gameState = 'AIMING'; hits = { white: false, yellow: false, red: false };
            p1Panel.classList.add('active-turn'); p2Panel.classList.remove('active-turn');
            stateIndicator.innerText = "Turno J1";
            balls[0].x = width * 0.2; balls[0].y = height * 0.5; balls[0].vx = 0; balls[0].vy = 0;
            balls[1].x = width * 0.4; balls[1].y = height * 0.45; balls[1].vx = 0; balls[1].vy = 0;
            balls[2].x = width * 0.8; balls[2].y = height * 0.5; balls[2].vx = 0; balls[2].vy = 0;
        }

        function getMousePos(e) {
            const r = canvas.getBoundingClientRect();
            const cX = e.touches ? e.touches[0].clientX : e.clientX;
            const cY = e.touches ? e.touches[0].clientY : e.clientY;
            return { x: cX - r.left, y: cY - r.top };
        }
        const handleStart = (e) => {
            if (gameState !== 'AIMING' || appState !== 'PLAYING') return;
            const pos = getMousePos(e);
            const cue = balls.find(b => b.label === (currentPlayer === 1 ? 'white' : 'yellow'));
            if (Math.sqrt((pos.x-cue.x)**2 + (pos.y-cue.y)**2) < 60) { isDragging = true; dragStart = pos; dragEnd = pos; }
        };
        const handleMove = (e) => { if (isDragging) dragEnd = getMousePos(e); };
        const handleEnd = () => {
            if (!isDragging) return; isDragging = false;
            const dx = dragStart.x - dragEnd.x; const dy = dragStart.y - dragEnd.y;
            currentShot.power = Math.min(Math.sqrt(dx*dx + dy*dy), 220) * 0.17;
            currentShot.angle = Math.atan2(dy, dx);
            if (currentShot.power > 0.8) {
                gameState = 'SETTING_SPIN'; spinBallName.innerText = (currentPlayer === 1) ? "Bola Blanca (J1)" : "Bola Amarilla (J2)";
                spinModal.classList.remove('hidden');
            }
        };

        document.getElementById('start-match-btn').addEventListener('click', startGame);
        document.getElementById('reset-btn').addEventListener('click', resetToMenu);
        document.getElementById('audio-toggle').addEventListener('click', (e) => {
            e.stopPropagation(); const isEnabled = SoundEngine.toggle();
            document.getElementById('audio-icon').innerHTML = isEnabled 
                ? '<path d="M6.717 3.55A.5.5 0 0 1 7 4v8a.5.5 0 0 1-.812.39L3.825 10.5H1.5A.5.5 0 0 1 1 10V6a.5.5 0 0 1 .5-.5h2.325l2.363-1.89a.5.5 0 0 1 .529-.06zM6 5.04L4.312 6.39A.5.5 0 0 1 4 6.5H2v3h2a.5.5 0 0 1 .312.11L6 10.96V5.04z"/><path d="M11.536 14.01A8.473 8.473 0 0 0 14.026 8a8.473 8.473 0 0 0-2.49-6.01l-.708.707A7.476 7.476 0 0 1 13.025 8c0 2.071-.84 3.946-2.197 5.303l.708.707z"/>'
                : '<path d="M6.717 3.55A.5.5 0 0 1 7 4v8a.5.5 0 0 1-.812.39L3.825 10.5H1.5A.5.5 0 0 1 1 10V6a.5.5 0 0 1 .5-.5h2.325l2.363-1.89a.5.5 0 0 1 .529-.06zM6 5.04L4.312 6.39A.5.5 0 0 1 4 6.5H2v3h2a.5.5 0 0 1 .312.11L6 10.96V5.04zM11.5 12.5a.5.5 0 0 1-.5-.5V4a.5.5 0 0 1 1 0v8a.5.5 0 0 1-.5.5z"/>';
        });

        canvas.addEventListener('touchstart', (e) => { e.preventDefault(); handleStart(e); }, {passive: false});
        window.addEventListener('touchmove', handleMove, {passive: false});
        window.addEventListener('touchend', handleEnd);
        canvas.addEventListener('mousedown', handleStart);
        window.addEventListener('mousemove', handleMove);
        window.addEventListener('mouseup', handleEnd);

        ballUI.addEventListener('click', (e) => {
            const r = ballUI.getBoundingClientRect();
            const x = e.clientX - r.left; const y = e.clientY - r.top;
            const nx = (x / 150) * 2 - 1; const ny = (y / 150) * 2 - 1;
            const dist = Math.sqrt(nx*nx + ny*ny);
            if (dist <= 0.95) { currentShot.spinX = nx; currentShot.spinY = -ny; impactDot.style.left = `${x}px`; impactDot.style.top = `${y}px`; }
        });

        document.getElementById('shoot-btn').addEventListener('click', () => {
            spinModal.classList.add('hidden'); gameState = 'ANIMATING';
            const cue = balls.find(b => b.label === (currentPlayer === 1 ? 'white' : 'yellow'));
            cue.vx = Math.cos(currentShot.angle) * currentShot.power; cue.vy = Math.sin(currentShot.angle) * currentShot.power;
            cue.spinX = currentShot.spinX; cue.spinY = currentShot.spinY;
            SoundEngine.playCue(Math.min(currentShot.power / 5, 1));
            stateIndicator.innerText = "Bolas en juego...";
        });

        document.getElementById('cancel-btn').addEventListener('click', () => { spinModal.classList.add('hidden'); gameState = 'AIMING'; });

        window.onload = init;
        window.onresize = init;
    </script>
</body>
</html>
