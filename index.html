<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Carambola Master Pro</title>
    
    <!-- Configuración PWA y Móvil -->
    <meta name="theme-color" content="#020617">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="CarambolaPro">
    <link rel="apple-touch-icon" href="https://cdn-icons-png.flaticon.com/512/3254/3254934.png">
    <link id="manifest-link" rel="manifest">

    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #020617;
            font-family: 'Segoe UI', system-ui, sans-serif;
            touch-action: none;
            user-select: none;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }
        
        #game-layout {
            display: flex;
            flex-direction: row;
            width: 100vw;
            height: 100vh;
            background-color: #020617;
        }

        #main-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        #table-area {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 5px;
            position: relative;
        }

        /* Barra de Dirección Inferior */
        #direction-controls {
            height: 50px;
            background: rgba(15, 23, 42, 0.5);
            display: flex;
            align-items: center;
            padding: 0 20px;
            gap: 15px;
            border-top: 1px solid rgba(255,255,255,0.05);
        }

        #dir-slider {
            flex: 1;
            -webkit-appearance: none;
            background: rgba(255,255,255,0.1);
            height: 4px;
            border-radius: 2px;
            outline: none;
        }

        #dir-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 24px;
            height: 24px;
            background: #10b981;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(16, 185, 129, 0.4);
            border: 2px solid white;
        }

        /* SIDEBAR REDISEÑADA */
        #sidebar {
            display: flex;
            flex-direction: row; /* Dos columnas internas */
            background: rgba(15, 23, 42, 0.98);
            backdrop-filter: blur(15px);
            border-left: 1px solid rgba(255,255,255,0.1);
            z-index: 20;
        }

        #power-column {
            width: 50px;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 15px 0;
            border-right: 1px solid rgba(255,255,255,0.05);
        }

        #actions-column {
            width: 120px;
            display: flex;
            flex-direction: column;
            padding: 10px;
            gap: 10px;
            justify-content: space-between;
        }

        canvas {
            box-shadow: 0 10px 40px rgba(0,0,0,0.9);
            border: 8px solid #1e1b18;
            border-radius: 4px;
            background-color: #064e3b;
            max-width: 98%;
            max-height: 98%;
        }

        #power-slider-container {
            width: 34px;
            flex: 1;
            background: rgba(255,255,255,0.05);
            border-radius: 17px;
            position: relative;
            border: 1px solid rgba(255,255,255,0.1);
            overflow: hidden;
            display: flex;
            flex-direction: column-reverse;
            cursor: ns-resize;
        }

        #power-fill {
            width: 100%;
            height: 0%;
            background: linear-gradient(to top, #10b981, #f59e0b, #ef4444);
            pointer-events: none;
        }

        .ball-selector {
            width: 140px;
            height: 140px;
            border-radius: 50%;
            background: radial-gradient(circle at 35% 35%, #ffffff, #cbd5e1);
            position: relative;
            box-shadow: inset -6px -6px 20px rgba(0,0,0,0.2), 0 15px 30px rgba(0,0,0,0.5);
        }

        #impact-dot {
            width: 12px; height: 12px; background: #ef4444; border: 2px solid white; border-radius: 50%;
            position: absolute; transform: translate(-50%, -50%); pointer-events: none;
            box-shadow: 0 0 10px rgba(239, 68, 68, 0.8);
        }

        .active-turn { border-color: #10b981 !important; border-width: 2px; }

        @media (orientation: portrait) {
            #game-layout { flex-direction: column; }
            #sidebar { width: 100%; height: auto; flex-direction: row; border-left: none; border-top: 1px solid rgba(255,255,255,0.1); }
            #power-column { width: 80px; height: 100%; border-right: 1px solid rgba(255,255,255,0.1); border-bottom: none; }
            #actions-column { flex: 1; flex-direction: row; width: auto; }
            #direction-controls { position: absolute; bottom: 120px; width: 100%; background: transparent; }
        }
    </style>
</head>
<body>

    <!-- Pantalla Inicial -->
    <div id="start-screen" class="fixed inset-0 z-50 bg-slate-950 flex flex-col items-center justify-center p-6 text-center text-white">
        <div class="mb-10">
            <h1 class="text-5xl font-black italic tracking-tighter mb-1 uppercase">Carambola <span class="text-emerald-500">Pro</span></h1>
            <p class="text-white/30 text-[10px] uppercase tracking-[0.4em]">Simulador de Alta Fidelidad</p>
        </div>
        <button id="start-match-btn" class="w-full max-w-xs py-5 bg-emerald-600 text-white font-black uppercase tracking-widest rounded-2xl shadow-2xl active:scale-95 transition-all">
            Iniciar Partida
        </button>
    </div>

    <!-- Layout de Juego -->
    <div id="game-layout" class="hidden">
        <div id="main-area">
            <div id="table-area">
                <canvas id="poolTable"></canvas>
            </div>
            
            <!-- DIRECCIÓN -->
            <div id="direction-controls">
                <span class="text-white/20 text-[9px] font-black uppercase">Dir</span>
                <input type="range" id="dir-slider" min="0" max="6.28" step="0.01" value="3.14">
                <span class="text-white/20 text-[9px] font-black uppercase">Angle</span>
            </div>
        </div>

        <!-- BARRA LATERAL MULTI-COLUMNA -->
        <aside id="sidebar">
            <!-- Columna 1: Potencia -->
            <div id="power-column">
                <p class="text-[7px] text-white/40 uppercase font-black mb-2 tracking-tighter">Fuerza</p>
                <div id="power-slider-container">
                    <div id="power-fill"></div>
                </div>
            </div>

            <!-- Columna 2: Marcadores y Botones -->
            <div id="actions-column">
                <div class="flex flex-col gap-2">
                    <div id="p1-panel" class="bg-black/40 border border-white/10 p-2 rounded-xl active-turn transition-all">
                        <div class="flex items-center gap-1.5 justify-center">
                            <div class="w-2 h-2 rounded-full bg-white shadow-sm"></div>
                            <p class="text-[8px] text-white/50 uppercase font-bold">J1</p>
                        </div>
                        <p id="score1" class="text-2xl font-black text-white text-center leading-none mt-1">0</p>
                    </div>
                    <div id="p2-panel" class="bg-black/40 border border-white/10 p-2 rounded-xl transition-all">
                        <div class="flex items-center gap-1.5 justify-center">
                            <div class="w-2 h-2 rounded-full bg-yellow-400 shadow-sm"></div>
                            <p class="text-[8px] text-white/50 uppercase font-bold">J2</p>
                        </div>
                        <p id="score2" class="text-2xl font-black text-white text-center leading-none mt-1">0</p>
                    </div>
                </div>

                <div id="state-indicator" class="bg-emerald-500/10 px-2 py-2 rounded-lg border border-emerald-500/20 text-emerald-400 text-[8px] font-black uppercase text-center">
                    Turno J1
                </div>

                <div class="flex flex-col gap-2">
                    <button id="spin-btn" class="bg-white/10 text-white py-2.5 rounded-xl text-[9px] font-black uppercase border border-white/10 active:bg-white/20">
                        Efecto
                    </button>
                    <button id="shoot-btn" class="bg-emerald-600 text-white py-4 rounded-xl text-[10px] font-black uppercase shadow-lg active:scale-95 disabled:opacity-30 transition-all">
                        GOLPEAR
                    </button>
                    <div class="flex gap-1.5">
                        <button id="audio-toggle" class="flex-1 bg-white/5 text-white py-2 rounded-lg flex justify-center border border-white/5 active:bg-white/10">
                            <svg id="audio-icon" width="14" height="14" fill="currentColor" viewBox="0 0 16 16"><path d="M6.717 3.55A.5.5 0 0 1 7 4v8a.5.5 0 0 1-.812.39L3.825 10.5H1.5A.5.5 0 0 1 1 10V6a.5.5 0 0 1 .5-.5h2.325l2.363-1.89a.5.5 0 0 1 .529-.06zM6 5.04L4.312 6.39A.5.5 0 0 1 4 6.5H2v3h2a.5.5 0 0 1 .312.11L6 10.96V5.04zM11.5 12.5a.5.5 0 0 1-.5-.5V4a.5.5 0 0 1 1 0v8a.5.5 0 0 1-.5.5z"/></svg>
                        </button>
                        <button id="reset-btn" class="flex-1 bg-white/5 text-white py-2 rounded-lg text-[8px] font-bold border border-white/5 active:bg-white/10">Menú</button>
                    </div>
                </div>
            </div>
        </aside>
    </div>

    <!-- MODAL EFECTO -->
    <div id="spin-modal" class="hidden fixed inset-0 bg-slate-950/95 backdrop-blur-md z-50 flex flex-col items-center justify-center">
        <div class="bg-slate-900 p-8 rounded-[2rem] border border-white/10 flex flex-col items-center shadow-2xl scale-110">
            <h3 class="text-white text-[10px] font-black mb-6 uppercase tracking-widest opacity-60 italic">Ajuste de Impacto</h3>
            <div class="ball-selector" id="ball-ui">
                <div style="top:50%; width:100%; height:1px; background:rgba(255,255,255,0.1); position:absolute;"></div>
                <div style="left:50%; height:100%; width:1px; background:rgba(255,255,255,0.1); position:absolute;"></div>
                <div id="impact-dot" style="top: 50%; left: 50%;"></div>
            </div>
            <button id="close-spin-btn" class="mt-8 w-full py-5 bg-emerald-600 text-white rounded-2xl text-xs font-black uppercase shadow-lg active:scale-95 transition-all">Confirmar Efecto</button>
        </div>
    </div>

    <script>
        // --- ESTADO GLOBAL ---
        let canvas, ctx, powerSlider, powerFill, dirSlider, shootBtn;
        let score1Element, score2Element, p1Panel, p2Panel, stateIndicator;
        let spinModal, ballUI, impactDot, startScreen, gameLayout;

        let hits = { white: false, yellow: false, red: false };
        let scores = { p1: 0, p2: 0 };
        let currentPlayer = 1;
        let gameState = 'AIMING'; 
        let appState = 'MENU'; 
        let currentShot = { power: 0, angle: 3.14, spinX: 0, spinY: 0 };
        let balls = [];
        let width, height;
        let isDraggingBall = false;
        let dragStartPos = { x: 0, y: 0 };

        // --- FÍSICA CALIBRADA ---
        const FRICTION = 0.995;          
        const WALL_BOUNCE = 0.81;      
        const BALL_BOUNCE = 0.98;
        const MIN_VEL = 0.02;
        const SPIN_FRICTION = 0.985;
        const BALL_RADIUS = 14;
        const MAX_PHYSICAL_POWER = 15.0; // Incrementada un 25%

        const SoundEngine = {
            audioCtx: null, enabled: false,
            init() { if (this.audioCtx) return; this.audioCtx = new (window.AudioContext || window.webkitAudioContext)(); this.enabled = true; },
            toggle() { if (!this.audioCtx) this.init(); this.enabled = !this.enabled; return this.enabled; },
            playClick(v = 1) {
                if (!this.enabled || !this.audioCtx) return;
                const o = this.audioCtx.createOscillator(); const g = this.audioCtx.createGain();
                o.type = 'sine'; o.frequency.setValueAtTime(800, this.audioCtx.currentTime);
                o.frequency.exponentialRampToValueAtTime(100, this.audioCtx.currentTime + 0.05);
                g.gain.setValueAtTime(v * 0.15, this.audioCtx.currentTime); 
                g.gain.exponentialRampToValueAtTime(0.01, this.audioCtx.currentTime + 0.05);
                o.connect(g); g.connect(this.audioCtx.destination); o.start(); o.stop(this.audioCtx.currentTime + 0.05);
            },
            playThud(v = 1) {
                if (!this.enabled || !this.audioCtx) return;
                const o = this.audioCtx.createOscillator(); const g = this.audioCtx.createGain();
                o.type = 'triangle'; o.frequency.setValueAtTime(150, this.audioCtx.currentTime);
                o.frequency.exponentialRampToValueAtTime(40, this.audioCtx.currentTime + 0.1);
                g.gain.setValueAtTime(v * 0.2, this.audioCtx.currentTime); 
                g.gain.exponentialRampToValueAtTime(0.01, this.audioCtx.currentTime + 0.1);
                o.connect(g); g.connect(this.audioCtx.destination); o.start(); o.stop(this.audioCtx.currentTime + 0.1);
            },
            playCue(v = 1) {
                if (!this.enabled || !this.audioCtx) return;
                const o = this.audioCtx.createOscillator(); const g = this.audioCtx.createGain();
                o.type = 'sine'; o.frequency.setValueAtTime(400, this.audioCtx.currentTime);
                g.gain.setValueAtTime(v * 0.25, this.audioCtx.currentTime); 
                g.gain.exponentialRampToValueAtTime(0.01, this.audioCtx.currentTime + 0.1);
                o.connect(g); g.connect(this.audioCtx.destination); o.start(); o.stop(this.audioCtx.currentTime + 0.1);
            },
            playSuccess() { if (!this.enabled || !this.audioCtx) return; [523, 659, 783].forEach((f, i) => { const o = this.audioCtx.createOscillator(); const g = this.audioCtx.createGain(); o.frequency.setValueAtTime(f, this.audioCtx.currentTime + i*0.1); g.gain.setValueAtTime(0.1, this.audioCtx.currentTime + i*0.1); g.gain.exponentialRampToValueAtTime(0.01, this.audioCtx.currentTime + i*0.1 + 0.4); o.connect(g); g.connect(this.audioCtx.destination); o.start(this.audioCtx.currentTime + i*0.1); o.stop(this.audioCtx.currentTime + i*0.1 + 0.4); }); }
        };

        class Ball {
            constructor(x, y, color, label) {
                this.x = x; this.y = y; this.vx = 0; this.vy = 0;
                this.color = color; this.label = label;
                this.radius = BALL_RADIUS; this.spinX = 0; this.spinY = 0; 
            }
            draw() {
                ctx.save();
                ctx.shadowBlur = 8; ctx.shadowColor = 'rgba(0,0,0,0.5)';
                ctx.shadowOffsetX = 3; ctx.shadowOffsetY = 3;
                ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                const grad = ctx.createRadialGradient(this.x - 4, this.y - 4, 1, this.x, this.y, this.radius);
                grad.addColorStop(0, '#ffffff'); grad.addColorStop(0.35, this.color); grad.addColorStop(1, this.color);
                ctx.fillStyle = grad; ctx.fill(); ctx.restore();
            }
            update() {
                if (appState !== 'PLAYING') return;
                
                // Efecto lateral intensificado
                if ((currentPlayer === 1 && this.label === 'white') || (currentPlayer === 2 && this.label === 'yellow')) {
                    this.vx += this.spinX * 0.012;
                    this.spinX *= SPIN_FRICTION;
                    this.spinY *= SPIN_FRICTION;
                }

                this.x += this.vx; this.y += this.vy;
                this.vx *= FRICTION; this.vy *= FRICTION;

                if (Math.abs(this.vx) < MIN_VEL && Math.abs(this.vy) < MIN_VEL) { this.vx = 0; this.vy = 0; }
                const spinS = 14.0;
                let hitW = false;
                if (this.x - this.radius < 0) { this.vx *= -WALL_BOUNCE; if (this.spinX !== 0) this.vy -= this.spinX * spinS; this.x = this.radius; hitW = true; } 
                else if (this.x + this.radius > width) { this.vx *= -WALL_BOUNCE; if (this.spinX !== 0) this.vy += this.spinX * spinS; this.x = width - this.radius; hitW = true; }
                if (this.y - this.radius < 0) { this.vy *= -WALL_BOUNCE; if (this.spinX !== 0) this.vx += this.spinX * spinS; this.y = this.radius; hitW = true; } 
                else if (this.y + this.radius > height) { this.vy *= -WALL_BOUNCE; if (this.spinX !== 0) this.vx -= this.spinX * spinS; this.y = height - this.radius; hitW = true; }
                if (hitW) { this.spinX *= 0.65; SoundEngine.playThud(Math.min(Math.sqrt(this.vx**2 + this.vy**2) / 4, 1)); }
            }
        }

        function setupDOM() {
            canvas = document.getElementById('poolTable');
            ctx = canvas ? canvas.getContext('2d') : null;
            score1Element = document.getElementById('score1');
            score2Element = document.getElementById('score2');
            p1Panel = document.getElementById('p1-panel');
            p2Panel = document.getElementById('p2-panel');
            stateIndicator = document.getElementById('state-indicator');
            spinModal = document.getElementById('spin-modal');
            ballUI = document.getElementById('ball-ui');
            impactDot = document.getElementById('impact-dot');
            startScreen = document.getElementById('start-screen');
            gameLayout = document.getElementById('game-layout');
            powerFill = document.getElementById('power-fill');
            powerSlider = document.getElementById('power-slider-container');
            dirSlider = document.getElementById('dir-slider');
            shootBtn = document.getElementById('shoot-btn');
        }

        function initGame() {
            setupDOM();
            if (!canvas) return;
            const area = document.getElementById('table-area').getBoundingClientRect();
            height = area.height - 20;
            width = Math.min(area.width - 20, height * 1.95);
            canvas.width = width; canvas.height = height;

            balls = [
                new Ball(width * 0.2, height * 0.5, '#ffffff', 'white'),
                new Ball(width * 0.4, height * 0.45, '#facc15', 'yellow'),
                new Ball(width * 0.8, height * 0.5, '#ef4444', 'red')
            ];
            
            // Power Slider
            powerSlider.onmousedown = (e) => handlePowerManual(e.clientY);
            powerSlider.ontouchstart = (e) => { e.preventDefault(); handlePowerManual(e.touches[0].clientY); };
            
            // Canvas Direct
            canvas.onmousedown = handleCanvasDown;
            canvas.ontouchstart = (e) => { e.preventDefault(); handleCanvasDown(e.touches[0]); };

            ballUI.onmousedown = handleSpinMouse;
            ballUI.ontouchstart = handleSpinTouch;

            requestAnimationFrame(gameLoop);
        }

        function handlePowerManual(ty) {
            const move = (ev) => {
                const y = ev.touches ? ev.touches[0].clientY : ev.clientY;
                const r = powerSlider.getBoundingClientRect();
                const pct = Math.max(0, Math.min(1, (r.bottom - y) / r.height));
                currentShot.power = pct * MAX_PHYSICAL_POWER;
                if(powerFill) powerFill.style.height = (pct * 100) + "%";
            };
            const end = () => { window.removeEventListener('mousemove', move); window.removeEventListener('mouseup', end); window.removeEventListener('touchmove', move); window.removeEventListener('touchend', end); };
            window.addEventListener('mousemove', move); window.addEventListener('mouseup', end);
            window.addEventListener('touchmove', move, {passive:false}); window.addEventListener('touchend', end);
            move({clientY: ty});
        }

        function handleCanvasDown(e) {
            if (gameState !== 'AIMING' || appState !== 'PLAYING') return;
            const pos = getMousePos(e);
            const cue = balls.find(b => b.label === (currentPlayer === 1 ? 'white' : 'yellow'));
            if (Math.sqrt((pos.x - cue.x)**2 + (pos.y - cue.y)**2) < 70) {
                isDraggingBall = true; dragStartPos = { x: cue.x, y: cue.y };
                const move = (ev) => {
                    const m = ev.touches ? ev.touches[0] : ev;
                    const mp = getMousePos(m);
                    const dx = dragStartPos.x - mp.x; const dy = dragStartPos.y - mp.y;
                    const dist = Math.min(Math.sqrt(dx*dx + dy*dy), 180);
                    const angle = Math.atan2(dy, dx);
                    if(dirSlider) dirSlider.value = angle < 0 ? angle + 6.28 : angle;
                    currentShot.angle = angle;
                    const pPct = dist / 180;
                    currentShot.power = pPct * MAX_PHYSICAL_POWER;
                    if(powerFill) powerFill.style.height = (pPct * 100) + "%";
                };
                const end = () => { isDraggingBall = false; window.removeEventListener('mousemove', move); window.removeEventListener('mouseup', end); window.removeEventListener('touchmove', move); window.removeEventListener('touchend', end); };
                window.addEventListener('mousemove', move); window.addEventListener('mouseup', end);
                window.addEventListener('touchmove', move, {passive:false}); window.addEventListener('touchend', end);
            }
        }

        function resolveCollisions() {
            for (let i = 0; i < balls.length; i++) {
                for (let j = i + 1; j < balls.length; j++) {
                    const b1 = balls[i]; const b2 = balls[j];
                    const dx = b2.x - b1.x; const dy = b2.y - b1.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < b1.radius + b2.radius) {
                        const cueL = (currentPlayer === 1) ? 'white' : 'yellow';
                        if (b1.label === cueL) hits[b2.label] = true;
                        else if (b2.label === cueL) hits[b1.label] = true;
                        const active = (b1.label === cueL) ? b1 : (b2.label === cueL ? b2 : null);
                        if (active) {
                            const target = (active === b1) ? b2 : b1;
                            const v = Math.sqrt(active.vx**2 + active.vy**2);
                            const p = active.spinY * 1.8 * (v * 0.85); 
                            const idx = target.x - active.x; const idy = target.y - active.y;
                            const idist = Math.sqrt(idx**2 + idy**2);
                            if (idist > 0) { active.vx += (idx / idist) * p; active.vy += (idy / idist) * p; }
                        }
                        SoundEngine.playClick(Math.min(Math.sqrt((b1.vx-b2.vx)**2 + (b1.vy-b2.vy)**2) / 8 + 0.2, 1));
                        const overlap = b1.radius + b2.radius - dist;
                        const nx = dx / dist; const ny = dy / dist;
                        b1.x -= nx * overlap / 2; b1.y -= ny * overlap / 2;
                        b2.x += nx * overlap / 2; b2.y += ny * overlap / 2;
                        const v1n = b1.vx * nx + b1.vy * ny; const v2n = b2.vx * nx + b2.vy * ny;
                        const v1t = -b1.vx * ny + b1.vy * nx; const v2t = -b2.vx * ny + b2.vy * nx;
                        b1.vx = (v2n * BALL_BOUNCE) * nx - v1t * ny; b1.vy = (v2n * BALL_BOUNCE) * ny + v1t * nx;
                        b2.vx = (v1n * BALL_BOUNCE) * nx - v2t * ny; b2.vy = (v1n * BALL_BOUNCE) * ny + v2t * nx;
                    }
                }
            }
        }

        function drawPredictivePath(startX, startY, angle, power) {
            let cx = startX; let cy = startY;
            let cvx = Math.cos(angle); let cvy = Math.sin(angle);
            let rd = power * 35; let maxB = 4; let b = 0;
            const cueL = (currentPlayer === 1) ? 'white' : 'yellow';
            ctx.beginPath(); ctx.setLineDash([4, 4]); ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)'; ctx.moveTo(cx, cy);
            while (rd > 0 && b < maxB) {
                let twx = (cvx > 0) ? (width - BALL_RADIUS - cx) / cvx : (BALL_RADIUS - cx) / cvx;
                let twy = (cvy > 0) ? (height - BALL_RADIUS - cy) / cvy : (BALL_RADIUS - cy) / cvy;
                let tw = Math.min(twx, twy); let tb = Infinity; let target = null;
                for (let bl of balls) {
                    if (bl.label === cueL) continue;
                    const dx = bl.x - cx; const dy = bl.y - cy;
                    const dot = dx * cvx + dy * cvy;
                    if (dot > 0) {
                        const d2 = dx*dx + dy*dy - dot*dot; const r2 = (BALL_RADIUS * 2) ** 2;
                        if (d2 < r2) { const t = dot - Math.sqrt(r2 - d2); if (t > 0.1 && t < tb) { tb = t; target = bl; } }
                    }
                }
                let tm = Math.min(tw, tb);
                if (tm > rd) { ctx.lineTo(cx + cvx * rd, cy + cvy * rd); rd = 0; } 
                else {
                    cx += cvx * tm; cy += cvy * tm; ctx.lineTo(cx, cy); rd -= tm;
                    if (tb < tw) {
                        const nx = (cx - target.x) / (BALL_RADIUS * 2); const ny = (cy - target.y) / (BALL_RADIUS * 2);
                        const dt = cvx * nx + cvy * ny; cvx -= 2 * dt * nx; cvy -= 2 * dt * ny;
                    } else { if (tm === twx) cvx *= -1; else cvy *= -1; }
                    b++;
                }
            }
            ctx.stroke(); ctx.setLineDash([]);
        }

        function gameLoop() {
            if (!ctx) return;
            ctx.clearRect(0, 0, width, height);
            if (appState === 'PLAYING') {
                ctx.fillStyle = '#064e3b'; ctx.fillRect(0, 0, width, height);
                ctx.fillStyle = 'rgba(255,255,255,0.08)';
                for(let i=1; i<8; i++) { ctx.beginPath(); ctx.arc((width/8)*i, 5, 1.2, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc((width/8)*i, height-5, 1.2, 0, Math.PI*2); ctx.fill(); }
                resolveCollisions();
                let moving = false;
                balls.forEach(ball => { ball.update(); ball.draw(); if (ball.vx !== 0 || ball.vy !== 0) moving = true; });
                if (gameState === 'ANIMATING' && !moving) { gameState = 'CHECKING'; checkResult(); }
                if (gameState === 'AIMING') {
                    const cue = balls.find(b => b.label === (currentPlayer === 1 ? 'white' : 'yellow'));
                    if (cue) {
                        if (!isDraggingBall) currentShot.angle = parseFloat(dirSlider.value);
                        drawPredictivePath(cue.x, cue.y, currentShot.angle, currentShot.power);
                        ctx.beginPath(); ctx.lineWidth = 4; ctx.lineCap = 'round';
                        const pb = currentShot.power * 4.0; 
                        ctx.moveTo(cue.x - Math.cos(currentShot.angle) * (25 + pb), cue.y - Math.sin(currentShot.angle) * (25 + pb));
                        ctx.lineTo(cue.x - Math.cos(currentShot.angle) * (140 + pb), cue.y - Math.sin(currentShot.angle) * (140 + pb));
                        ctx.strokeStyle = 'rgba(255,255,255,0.2)'; ctx.stroke();
                    }
                }
                if (shootBtn) shootBtn.disabled = (currentShot.power < 0.1);
            }
            requestAnimationFrame(gameLoop);
        }

        function checkResult() {
            let carom = (currentPlayer === 1) ? (hits.yellow && hits.red) : (hits.white && hits.red);
            if (carom) {
                if (currentPlayer === 1) { scores.p1++; if(score1Element) score1Element.innerText = scores.p1; } 
                else { scores.p2++; if(score2Element) score2Element.innerText = scores.p2; }
                SoundEngine.playSuccess(); if(stateIndicator) stateIndicator.innerText = "¡CARAMBOLA!";
            } else {
                currentPlayer = (currentPlayer === 1) ? 2 : 1;
                if(stateIndicator) stateIndicator.innerText = "Turno J" + currentPlayer;
                if(p1Panel) p1Panel.className = (currentPlayer === 1) ? "bg-black/60 border border-white/10 p-2 rounded-xl active-turn transition-all" : "bg-black/40 border border-white/10 p-2 rounded-xl transition-all";
                if(p2Panel) p2Panel.className = (currentPlayer === 2) ? "bg-black/60 border border-white/10 p-2 rounded-xl active-turn transition-all" : "bg-black/40 border border-white/10 p-2 rounded-xl transition-all";
            }
            currentShot.power = 0; if (powerFill) powerFill.style.height = "0%";
            setTimeout(() => { if (appState === 'PLAYING') { gameState = 'AIMING'; hits = { white: false, yellow: false, red: false }; } }, 1000);
        }

        function handleSpinMouse(e) {
            const r = ballUI.getBoundingClientRect(); updateSpin(e.clientX, e.clientY, r);
            const mv = (ev) => updateSpin(ev.clientX, ev.clientY, r);
            const up = () => { window.removeEventListener('mousemove', mv); window.removeEventListener('mouseup', up); };
            window.addEventListener('mousemove', mv); window.addEventListener('mouseup', up);
        }
        function handleSpinTouch(e) {
            const r = ballUI.getBoundingClientRect(); updateSpin(e.touches[0].clientX, e.touches[0].clientY, r);
            const mv = (ev) => updateSpin(ev.touches[0].clientX, ev.touches[0].clientY, r);
            const up = () => { window.removeEventListener('touchmove', mv); window.removeEventListener('touchend', up); };
            window.addEventListener('touchmove', mv); window.addEventListener('touchend', up);
        }
        function updateSpin(tx, ty, r) {
            const nx = ((tx - r.left) / r.width) * 2 - 1; const ny = ((ty - r.top) / r.height) * 2 - 1;
            if (Math.sqrt(nx*nx + ny*ny) <= 0.95) { currentShot.spinX = nx; currentShot.spinY = -ny; if(impactDot) { impactDot.style.left = (nx+1)*50+"%"; impactDot.style.top = (ny+1)*50+"%"; } }
        }
        function getMousePos(e) { const r = canvas.getBoundingClientRect(); return { x: (e.clientX || e.pageX) - r.left, y: (e.clientY || e.pageY) - r.top }; }
        function resetMatch() {
            scores = { p1: 0, p2: 0 }; if(score1Element) score1Element.innerText = 0; if(score2Element) score2Element.innerText = 0;
            currentPlayer = 1; gameState = 'AIMING'; hits = { white: false, yellow: false, red: false };
            if(p1Panel) p1Panel.className = "bg-black/60 border border-white/10 p-2 rounded-xl active-turn transition-all";
            if(p2Panel) p2Panel.className = "bg-black/40 border border-white/10 p-2 rounded-xl transition-all";
            if(stateIndicator) stateIndicator.innerText = "Turno J1"; if(powerFill) powerFill.style.height = "0%";
            balls[0].x = width * 0.2; balls[0].y = height * 0.5; balls[1].x = width * 0.4; balls[1].y = height * 0.45; balls[2].x = width * 0.8; balls[2].y = height * 0.5;
            balls.forEach(b => { b.vx = 0; b.vy = 0; });
        }

        window.onload = () => {
            setupDOM();
            document.getElementById('start-match-btn').onclick = () => { SoundEngine.init(); startScreen.classList.add('hidden'); gameLayout.classList.remove('hidden'); appState = 'PLAYING'; initGame(); resetMatch(); };
            document.getElementById('reset-btn').onclick = () => location.reload();
            document.getElementById('spin-btn').onclick = () => { if (gameState === 'AIMING') spinModal.classList.remove('hidden'); };
            document.getElementById('close-spin-btn').onclick = () => spinModal.classList.add('hidden');
            document.getElementById('audio-toggle').onclick = () => SoundEngine.toggle();
            shootBtn.onclick = () => {
                if (gameState !== 'AIMING' || currentShot.power < 0.1) return;
                gameState = 'ANIMATING';
                const cue = balls.find(b => b.label === (currentPlayer === 1 ? 'white' : 'yellow'));
                if(cue) {
                    cue.vx = Math.cos(currentShot.angle) * currentShot.power; cue.vy = Math.sin(currentShot.angle) * currentShot.power;
                    cue.spinX = currentShot.spinX; cue.spinY = currentShot.spinY;
                    SoundEngine.playCue(Math.min(currentShot.power / 3, 1));
                }
            };
        };
        window.onresize = () => { if(appState === 'PLAYING') initGame(); };
    </script>
</body>
</html>
