<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Carambola Master Pro</title>
    
    <!-- Configuración PWA y Móvil -->
    <meta name="theme-color" content="#020617">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="CarambolaPro">
    <link rel="apple-touch-icon" href="https://cdn-icons-png.flaticon.com/512/3254/3254934.png">
    <link id="manifest-link" rel="manifest">

    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #020617;
            font-family: 'Segoe UI', system-ui, sans-serif;
            touch-action: none;
            user-select: none;
        }
        canvas {
            display: block;
            margin: auto;
            box-shadow: 0 25px 60px rgba(0,0,0,1);
            border: 12px solid #1e1b18;
            border-radius: 6px;
            background-color: #064e3b;
        }
        .ball-selector {
            width: 150px;
            height: 150px;
            border-radius: 50%;
            background: radial-gradient(circle at 35% 35%, #ffffff, #cbd5e1);
            position: relative;
            cursor: crosshair;
            box-shadow: inset -6px -6px 20px rgba(0,0,0,0.2), 0 15px 30px rgba(0,0,0,0.5);
            border: 2px solid rgba(255,255,255,0.2);
        }
        #impact-dot {
            width: 14px;
            height: 14px;
            background: #ef4444;
            border: 2px solid white;
            border-radius: 50%;
            position: absolute;
            transform: translate(-50%, -50%);
            pointer-events: none;
            box-shadow: 0 0 10px rgba(239, 68, 68, 0.8);
        }
        .crosshair-h { position: absolute; top: 50%; left: 0; width: 100%; height: 1px; background: rgba(0,0,0,0.1); pointer-events: none; }
        .crosshair-v { position: absolute; left: 50%; top: 0; width: 1px; height: 100%; background: rgba(0,0,0,0.1); pointer-events: none; }
        
        .active-turn {
            border-color: #10b981 !important;
            box-shadow: 0 0 20px rgba(16, 185, 129, 0.4);
            transform: scale(1.05);
        }

        #audio-toggle, #reset-btn {
            pointer-events: auto;
        }
        
        @media (orientation: landscape) {
            #ui-overlay { padding-top: 10px; }
        }

        .fade-in { animation: fadeIn 0.5s ease-out; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen">

    <!-- Pantalla Inicial (Menú) -->
    <div id="start-screen" class="fixed inset-0 z-50 bg-slate-950 flex flex-col items-center justify-center p-6 text-center">
        <div class="mb-12">
            <h1 class="text-white text-5xl font-black italic tracking-tighter mb-2">CARAMBOLA <span class="text-emerald-500">PRO</span></h1>
            <p class="text-white/40 text-xs uppercase tracking-[0.3em]">Simulador de Alta Precisión</p>
        </div>
        
        <div class="space-y-4 w-full max-w-xs">
            <button id="start-match-btn" class="w-full py-5 bg-gradient-to-br from-emerald-400 to-emerald-700 text-white font-black uppercase tracking-widest rounded-2xl shadow-2xl shadow-emerald-500/20 active:scale-95 transition-all">
                Iniciar Partida
            </button>
            <p class="text-white/20 text-[10px] uppercase">Dos Jugadores · Física Realista · PWA</p>
        </div>
    </div>

    <!-- UI Superior - Doble Marcador -->
    <div id="ui-overlay" class="hidden fixed top-0 left-0 w-full p-4 flex justify-around items-start z-10 pointer-events-none gap-4 mt-safe">
        <!-- Jugador 1 (Blanca) -->
        <div id="p1-panel" class="bg-black/80 backdrop-blur-xl p-3 rounded-2xl border border-white/10 text-white shadow-2xl flex-1 max-w-[160px] transition-all duration-300 active-turn">
            <div class="flex items-center gap-2 mb-1">
                <div class="w-3 h-3 rounded-full bg-white shadow-sm"></div>
                <p class="text-[9px] uppercase tracking-widest opacity-60 font-bold">Jugador 1</p>
            </div>
            <p class="text-[10px] uppercase tracking-tighter opacity-40 mb-1 font-bold text-center">CARAMBOLAS</p>
            <p id="score1" class="text-3xl font-black italic text-center">0</p>
        </div>

        <!-- Centro: Estado y Sonido -->
        <div class="flex flex-col items-center gap-3">
            <div id="state-indicator" class="bg-emerald-500/20 backdrop-blur-xl px-4 py-2 rounded-full border border-emerald-500/30 text-emerald-400 text-[10px] font-black uppercase tracking-[0.1em] shadow-lg whitespace-nowrap">
                Turno J1
            </div>
            <button id="audio-toggle" class="bg-white/10 hover:bg-white/20 text-white p-2 rounded-full border border-white/10 transition-colors pointer-events-auto">
                <svg id="audio-icon" xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                    <path d="M6.717 3.55A.5.5 0 0 1 7 4v8a.5.5 0 0 1-.812.39L3.825 10.5H1.5A.5.5 0 0 1 1 10V6a.5.5 0 0 1 .5-.5h2.325l2.363-1.89a.5.5 0 0 1 .529-.06zM6 5.04L4.312 6.39A.5.5 0 0 1 4 6.5H2v3h2a.5.5 0 0 1 .312.11L6 10.96V5.04z"/>
                    <path d="M11.536 14.01A8.473 8.473 0 0 0 14.026 8a8.473 8.473 0 0 0-2.49-6.01l-.708.707A7.476 7.476 0 0 1 13.025 8c0 2.071-.84 3.946-2.197 5.303l.708.707z"/>
                </svg>
            </button>
        </div>

        <!-- Jugador 2 (Amarilla) -->
        <div id="p2-panel" class="bg-black/80 backdrop-blur-xl p-3 rounded-2xl border border-white/10 text-white shadow-2xl flex-1 max-w-[160px] transition-all duration-300 text-right">
            <div class="flex items-center justify-end gap-2 mb-1">
                <p class="text-[9px] uppercase tracking-widest opacity-60 font-bold">Jugador 2</p>
                <div class="w-3 h-3 rounded-full bg-yellow-400 shadow-sm"></div>
            </div>
            <p class="text-[10px] uppercase tracking-tighter opacity-40 mb-1 font-bold text-center">CARAMBOLAS</p>
            <p id="score2" class="text-3xl font-black italic text-center">0</p>
        </div>
    </div>

    <!-- Mesa de Juego -->
    <div id="game-container" class="relative hidden">
        <canvas id="poolTable"></canvas>
        
        <!-- Botón Reset (Esquina inferior) -->
        <button id="reset-btn" class="absolute -bottom-12 right-0 bg-white/5 hover:bg-white/10 border border-white/10 px-3 py-1.5 rounded-lg text-white/40 text-[9px] uppercase font-bold tracking-widest transition-all">
            Reset
        </button>
    </div>

    <!-- Selector de Efecto -->
    <div id="spin-modal" class="hidden fixed inset-0 bg-slate-950/95 backdrop-blur-md z-20 flex flex-col items-center justify-center">
        <div class="bg-slate-900 p-8 rounded-[2.5rem] border border-white/10 flex flex-col items-center shadow-2xl scale-110">
            <h3 class="text-white text-[10px] font-black mb-6 uppercase tracking-[0.3em] opacity-70 italic text-center leading-relaxed">
                Punto de contacto<br><span id="spin-ball-name" class="text-emerald-400">Bola Blanca</span>
            </h3>
            
            <div class="ball-selector" id="ball-ui">
                <div class="crosshair-h"></div>
                <div class="crosshair-v"></div>
                <div id="impact-dot" style="top: 50%; left: 50%;"></div>
            </div>

            <div class="mt-8 flex gap-4 w-full">
                <button id="cancel-btn" class="flex-1 py-4 bg-white/5 text-white/70 rounded-2xl text-[10px] font-black uppercase tracking-widest hover:bg-white/10 transition-all border border-white/5">Atrás</button>
                <button id="shoot-btn" class="flex-1 py-4 bg-gradient-to-br from-orange-400 to-red-600 text-white rounded-2xl text-[10px] font-black uppercase tracking-widest shadow-xl shadow-orange-500/20 active:scale-95 transition-all">¡Golpear!</button>
            </div>
        </div>
    </div>

    <script>
        /**
         * MOTOR DE SONIDO SINTETIZADO
         */
        const SoundEngine = {
            ctx: null,
            enabled: false,

            init() {
                if (this.ctx) return;
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                this.enabled = true;
            },

            toggle() {
                if (!this.ctx) this.init();
                this.enabled = !this.enabled;
                return this.enabled;
            },

            playClick(volume = 1) {
                if (!this.enabled || !this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(800, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(100, this.ctx.currentTime + 0.05);
                gain.gain.setValueAtTime(volume * 0.2, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.05);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.05);
            },

            playThud(volume = 1) {
                if (!this.enabled || !this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(150, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(40, this.ctx.currentTime + 0.1);
                gain.gain.setValueAtTime(volume * 0.3, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.1);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.1);
            },

            playCue(volume = 1) {
                if (!this.enabled || !this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(400, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(200, this.ctx.currentTime + 0.1);
                gain.gain.setValueAtTime(volume * 0.2, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.1);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.1);
            },

            playSuccess() {
                if (!this.enabled || !this.ctx) return;
                const playNote = (freq, time) => {
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    osc.frequency.setValueAtTime(freq, this.ctx.currentTime + time);
                    gain.gain.setValueAtTime(0, this.ctx.currentTime + time);
                    gain.gain.linearRampToValueAtTime(0.2, this.ctx.currentTime + time + 0.05);
                    gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + time + 0.5);
                    osc.connect(gain);
                    gain.connect(this.ctx.destination);
                    osc.start(this.ctx.currentTime + time);
                    osc.stop(this.ctx.currentTime + time + 0.5);
                };
                playNote(523.25, 0); 
                playNote(659.25, 0.1); 
                playNote(783.99, 0.2); 
            },

            playFail() {
                if (!this.enabled || !this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.frequency.setValueAtTime(200, this.ctx.currentTime);
                osc.frequency.linearRampToValueAtTime(100, this.ctx.currentTime + 0.3);
                gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
                gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.3);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.3);
            }
        };

        const canvas = document.getElementById('poolTable');
        const ctx = canvas.getContext('2d');
        const score1Element = document.getElementById('score1');
        const score2Element = document.getElementById('score2');
        const p1Panel = document.getElementById('p1-panel');
        const p2Panel = document.getElementById('p2-panel');
        const stateIndicator = document.getElementById('state-indicator');
        const spinModal = document.getElementById('spin-modal');
        const ballUI = document.getElementById('ball-ui');
        const impactDot = document.getElementById('impact-dot');
        const spinBallName = document.getElementById('spin-ball-name');
        const audioBtn = document.getElementById('audio-toggle');
        const audioIcon = document.getElementById('audio-icon');
        const startScreen = document.getElementById('start-screen');
        const gameContainer = document.getElementById('game-container');
        const uiOverlay = document.getElementById('ui-overlay');

        let width, height;
        let balls = [];
        let currentPlayer = 1;
        let scores = { p1: 0, p2: 0 };
        let gameState = 'AIMING'; 
        let appState = 'MENU'; // MENU, PLAYING
        
        let currentShot = { power: 0, angle: 0, spinX: 0, spinY: 0 };
        let isDragging = false;
        let dragStart = { x: 0, y: 0 };
        let dragEnd = { x: 0, y: 0 };

        const FRICTION = 0.9975;
        const WALL_BOUNCE = 0.82;
        const BALL_BOUNCE = 0.98;
        const MIN_VEL = 0.02;
        const SPIN_FRICTION = 0.985;
        const BALL_RADIUS = 14;

        class Ball {
            constructor(x, y, color, label) {
                this.x = x; this.y = y;
                this.vx = 0; this.vy = 0;
                this.color = color;
                this.label = label;
                this.radius = BALL_RADIUS;
                this.spinX = 0; 
                this.spinY = 0; 
            }

            draw() {
                ctx.save();
                ctx.shadowBlur = 12;
                ctx.shadowColor = 'rgba(0,0,0,0.4)';
                ctx.shadowOffsetX = 4;
                ctx.shadowOffsetY = 4;

                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                const grad = ctx.createRadialGradient(this.x - 5, this.y - 5, 2, this.x, this.y, this.radius);
                grad.addColorStop(0, '#ffffff');
                grad.addColorStop(0.3, this.color);
                grad.addColorStop(1, this.color);
                ctx.fillStyle = grad;
                ctx.fill();
                ctx.restore();
                
                ctx.beginPath();
                ctx.arc(this.x - 4, this.y - 4, 3, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255,255,255,0.3)';
                ctx.fill();
            }

            update() {
                if (appState !== 'PLAYING') return;
                this.x += this.vx;
                this.y += this.vy;

                this.vx *= FRICTION;
                this.vy *= FRICTION;

                if ((currentPlayer === 1 && this.label === 'white') || (currentPlayer === 2 && this.label === 'yellow')) {
                    this.vx += this.spinX * 0.006;
                    this.spinX *= SPIN_FRICTION;
                    this.spinY *= SPIN_FRICTION;
                }

                if (Math.abs(this.vx) < MIN_VEL && Math.abs(this.vy) < MIN_VEL) {
                    this.vx = 0; this.vy = 0;
                }

                const spinStrength = 7.5;
                let hitWall = false;
                if (this.x - this.radius < 0) {
                    this.vx *= -WALL_BOUNCE;
                    if (this.spinX !== 0) this.vy -= this.spinX * spinStrength;
                    this.x = this.radius;
                    this.spinX *= 0.6;
                    hitWall = true;
                } else if (this.x + this.radius > width) {
                    this.vx *= -WALL_BOUNCE;
                    if (this.spinX !== 0) this.vy += this.spinX * spinStrength;
                    this.x = width - this.radius;
                    this.spinX *= 0.6;
                    hitWall = true;
                }

                if (this.y - this.radius < 0) {
                    this.vy *= -WALL_BOUNCE;
                    if (this.spinX !== 0) this.vx += this.spinX * spinStrength;
                    this.y = this.radius;
                    this.spinX *= 0.6;
                    hitWall = true;
                } else if (this.y + this.radius > height) {
                    this.vy *= -WALL_BOUNCE;
                    if (this.spinX !== 0) this.vx -= this.spinX * spinStrength;
                    this.y = height - this.radius;
                    this.spinX *= 0.6;
                    hitWall = true;
                }

                if (hitWall) {
                    const speed = Math.sqrt(this.vx**2 + this.vy**2);
                    SoundEngine.playThud(Math.min(speed / 5, 1));
                }
            }
        }

        function init() {
            const h = window.innerHeight * 0.55;
            height = h;
            width = h * 1.9;
            canvas.width = width;
            canvas.height = height;

            balls = [
                new Ball(width * 0.2, height * 0.5, '#ffffff', 'white'),
                new Ball(width * 0.4, height * 0.45, '#facc15', 'yellow'),
                new Ball(width * 0.8, height * 0.5, '#ef4444', 'red')
            ];
            
            // PWA Manifest Dinámico
            const manifest = {
                "name": "Carambola Master Pro",
                "short_name": "CarambolaPro",
                "start_url": ".",
                "display": "standalone",
                "orientation": "landscape",
                "background_color": "#020617",
                "theme_color": "#020617",
                "icons": [{"src": "https://cdn-icons-png.flaticon.com/512/3254/3254934.png", "sizes": "512x512", "type": "image/png"}]
            };
            const stringManifest = JSON.stringify(manifest);
            const blob = new Blob([stringManifest], {type: 'application/json'});
            const manifestURL = URL.createObjectURL(blob);
            document.querySelector('#manifest-link').setAttribute('href', manifestURL);

            requestAnimationFrame(gameLoop);
        }

        let hits = { white: false, yellow: false, red: false };

        function resolveCollisions() {
            for (let i = 0; i < balls.length; i++) {
                for (let j = i + 1; j < balls.length; j++) {
                    const b1 = balls[i];
                    const b2 = balls[j];
                    const dx = b2.x - b1.x;
                    const dy = b2.y - b1.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < b1.radius + b2.radius) {
                        const cueBallLabel = (currentPlayer === 1) ? 'white' : 'yellow';
                        
                        if (b1.label === cueBallLabel) hits[b2.label] = true;
                        else if (b2.label === cueBallLabel) hits[b1.label] = true;
                        
                        const effectIntensity = 1.2;
                        if (b1.label === cueBallLabel) {
                            const impactVel = Math.sqrt(b1.vx * b1.vx + b1.vy * b1.vy);
                            const pushFactor = b1.spinY * effectIntensity * (impactVel * 0.8);
                            b1.vx += (dx / dist) * pushFactor;
                            b1.vy += (dy / dist) * pushFactor;
                        } else if (b2.label === cueBallLabel) {
                            const impactVel = Math.sqrt(b2.vx * b2.vx + b2.vy * b2.vy);
                            const pushFactor = b2.spinY * effectIntensity * (impactVel * 0.8);
                            b2.vx -= (dx / dist) * pushFactor;
                            b2.vy -= (dy / dist) * pushFactor;
                        }

                        const relativeVel = Math.sqrt((b1.vx - b2.vx)**2 + (b1.vy - b2.vy)**2);
                        SoundEngine.playClick(Math.min(relativeVel / 10 + 0.2, 1));

                        const overlap = b1.radius + b2.radius - dist;
                        const nx = dx / dist; const ny = dy / dist;
                        b1.x -= nx * overlap / 2; b1.y -= ny * overlap / 2;
                        b2.x += nx * overlap / 2; b2.y += ny * overlap / 2;

                        const v1n = b1.vx * nx + b1.vy * ny;
                        const v2n = b2.vx * nx + b2.vy * ny;
                        const v1t = -b1.vx * ny + b1.vy * nx;
                        const v2t = -b2.vx * ny + b2.vy * nx;

                        b1.vx = (v2n * BALL_BOUNCE) * nx - v1t * ny;
                        b1.vy = (v2n * BALL_BOUNCE) * ny + v1t * nx;
                        b2.vx = (v1n * BALL_BOUNCE) * nx - v2t * ny;
                        b2.vy = (v1n * BALL_BOUNCE) * ny + v2t * nx;
                    }
                }
            }
        }

        function drawPredictivePath(startX, startY, angle, power) {
            let currentX = startX;
            let currentY = startY;
            let currentVX = Math.cos(angle);
            let currentVY = Math.sin(angle);
            
            let remainingDist = power * 15;
            let maxBounces = 4;
            let bounces = 0;
            const cueBallLabel = (currentPlayer === 1) ? 'white' : 'yellow';

            ctx.beginPath();
            ctx.setLineDash([4, 4]);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
            ctx.moveTo(currentX, currentY);

            while (remainingDist > 0 && bounces < maxBounces) {
                let tWallX = Infinity, tWallY = Infinity;
                if (currentVX > 0) tWallX = (width - BALL_RADIUS - currentX) / currentVX;
                else if (currentVX < 0) tWallX = (BALL_RADIUS - currentX) / currentVX;
                if (currentVY > 0) tWallY = (height - BALL_RADIUS - currentY) / currentVY;
                else if (currentVY < 0) tWallY = (BALL_RADIUS - currentY) / currentVY;

                let tWall = Math.min(tWallX, tWallY);
                let tBall = Infinity;
                let targetBall = null;

                for (let ball of balls) {
                    if (ball.label === cueBallLabel) continue;
                    const dx = ball.x - currentX;
                    const dy = ball.y - currentY;
                    const dot = dx * currentVX + dy * currentVY;
                    if (dot > 0) {
                        const d2 = dx*dx + dy*dy - dot*dot;
                        const r2 = (BALL_RADIUS * 2) * (BALL_RADIUS * 2);
                        if (d2 < r2) {
                            const t = dot - Math.sqrt(r2 - d2);
                            if (t > 0.1 && t < tBall) { tBall = t; targetBall = ball; }
                        }
                    }
                }

                let tMin = Math.min(tWall, tBall);
                if (tMin > remainingDist) {
                    ctx.lineTo(currentX + currentVX * remainingDist, currentY + currentVY * remainingDist);
                    remainingDist = 0;
                } else {
                    currentX += currentVX * tMin;
                    currentY += currentVY * tMin;
                    ctx.lineTo(currentX, currentY);
                    remainingDist -= tMin;

                    if (tBall < tWall) {
                        const nx = (currentX - targetBall.x) / (BALL_RADIUS * 2);
                        const ny = (currentY - targetBall.y) / (BALL_RADIUS * 2);
                        const dot = currentVX * nx + currentVY * ny;
                        currentVX -= 2 * dot * nx;
                        currentVY -= 2 * dot * ny;
                    } else {
                        if (tMin === tWallX) currentVX *= -1;
                        else currentVY *= -1;
                    }
                    bounces++;
                }
            }
            ctx.stroke();
            ctx.setLineDash([]);
        }

        function gameLoop() {
            ctx.clearRect(0, 0, width, height);
            
            if (appState === 'PLAYING') {
                // Dibujar Mesa
                ctx.fillStyle = '#064e3b';
                ctx.fillRect(0, 0, width, height);
                
                ctx.fillStyle = 'rgba(255,255,255,0.2)';
                for(let i=1; i<8; i++) {
                    ctx.beginPath(); ctx.arc((width/8)*i, 6, 2, 0, Math.PI*2); ctx.fill();
                    ctx.beginPath(); ctx.arc((width/8)*i, height-6, 2, 0, Math.PI*2); ctx.fill();
                }

                resolveCollisions();

                let moving = false;
                balls.forEach(ball => {
                    ball.update();
                    ball.draw();
                    if (ball.vx !== 0 || ball.vy !== 0) moving = true;
                });

                if (gameState === 'ANIMATING' && !moving) {
                    gameState = 'CHECKING';
                    checkResult();
                }

                if (gameState === 'AIMING' && isDragging) {
                    const cueBall = balls.find(b => b.label === (currentPlayer === 1 ? 'white' : 'yellow'));
                    const dx = dragStart.x - dragEnd.x;
                    const dy = dragStart.y - dragEnd.y;
                    const dist = Math.min(Math.sqrt(dx*dx + dy*dy), 220);
                    const angle = Math.atan2(dy, dx);
                    drawPredictivePath(cueBall.x, cueBall.y, angle, dist * 0.17);
                    ctx.beginPath();
                    ctx.lineWidth = 6;
                    ctx.lineCap = 'round';
                    ctx.moveTo(cueBall.x - Math.cos(angle) * 30, cueBall.y - Math.sin(angle) * 30);
                    ctx.lineTo(cueBall.x - Math.cos(angle) * (30 + dist), cueBall.y - Math.sin(angle) * (30 + dist));
                    ctx.strokeStyle = 'rgba(255,255,255,0.15)';
                    ctx.stroke();
                }
            }
            requestAnimationFrame(gameLoop);
        }

        function checkResult() {
            let carom = false;
            if (currentPlayer === 1) { if (hits.yellow && hits.red) carom = true; } 
            else { if (hits.white && hits.red) carom = true; }

            if (carom) {
                if (currentPlayer === 1) { scores.p1++; score1Element.innerText = scores.p1; } 
                else { scores.p2++; score2Element.innerText = scores.p2; }
                SoundEngine.playSuccess();
                stateIndicator.innerText = "¡CARAMBOLA! J" + currentPlayer + " repite";
                stateIndicator.className = "bg-yellow-500 text-black px-4 py-2 rounded-full border border-yellow-200 text-[10px] font-black uppercase tracking-[0.1em] shadow-lg animate-bounce";
            } else {
                SoundEngine.playFail();
                currentPlayer = (currentPlayer === 1) ? 2 : 1;
                stateIndicator.innerText = "Fallo. Turno J" + currentPlayer;
                stateIndicator.className = "bg-red-500 text-white px-4 py-2 rounded-full border border-red-300 text-[10px] font-black uppercase tracking-[0.1em] shadow-lg";
                if (currentPlayer === 1) { p1Panel.classList.add('active-turn'); p2Panel.classList.remove('active-turn'); } 
                else { p2Panel.classList.add('active-turn'); p1Panel.classList.remove('active-turn'); }
            }
            
            setTimeout(() => {
                if (appState !== 'PLAYING') return;
                gameState = 'AIMING';
                stateIndicator.innerText = "Turno J" + currentPlayer;
                stateIndicator.className = "bg-emerald-500/20 text-emerald-400 px-4 py-2 rounded-full border border-emerald-500/30 text-[10px] font-black uppercase tracking-[0.1em] shadow-lg";
                hits = { white: false, yellow: false, red: false };
            }, 1800);
        }

        // --- SISTEMA DE NAVEGACIÓN ---

        function startGame() {
            SoundEngine.init();
            startScreen.classList.add('hidden');
            gameContainer.classList.remove('hidden');
            uiOverlay.classList.remove('hidden');
            uiOverlay.classList.add('flex');
            appState = 'PLAYING';
            resetMatch();
        }

        function resetToMenu() {
            startScreen.classList.remove('hidden');
            gameContainer.classList.add('hidden');
            uiOverlay.classList.add('hidden');
            uiOverlay.classList.remove('flex');
            appState = 'MENU';
        }

        function resetMatch() {
            scores = { p1: 0, p2: 0 };
            score1Element.innerText = 0;
            score2Element.innerText = 0;
            currentPlayer = 1;
            gameState = 'AIMING';
            hits = { white: false, yellow: false, red: false };
            p1Panel.classList.add('active-turn');
            p2Panel.classList.remove('active-turn');
            stateIndicator.innerText = "Turno J1";
            stateIndicator.className = "bg-emerald-500/20 text-emerald-400 px-4 py-2 rounded-full border border-emerald-500/30 text-[10px] font-black uppercase tracking-[0.1em] shadow-lg";
            
            // Posicionar bolas
            balls[0].x = width * 0.2; balls[0].y = height * 0.5; balls[0].vx = 0; balls[0].vy = 0;
            balls[1].x = width * 0.4; balls[1].y = height * 0.45; balls[1].vx = 0; balls[1].vy = 0;
            balls[2].x = width * 0.8; balls[2].y = height * 0.5; balls[2].vx = 0; balls[2].vy = 0;
        }

        // --- GESTIÓN DE INPUT ---

        function getMousePos(e) {
            const r = canvas.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            return { x: clientX - r.left, y: clientY - r.top };
        }

        const handleStart = (e) => {
            if (gameState !== 'AIMING' || appState !== 'PLAYING') return;
            const pos = getMousePos(e);
            const cueBall = balls.find(b => b.label === (currentPlayer === 1 ? 'white' : 'yellow'));
            if (Math.sqrt((pos.x-cueBall.x)**2 + (pos.y-cueBall.y)**2) < 60) {
                isDragging = true; dragStart = pos; dragEnd = pos;
            }
        };

        const handleMove = (e) => { if (isDragging) dragEnd = getMousePos(e); };

        const handleEnd = () => {
            if (!isDragging) return;
            isDragging = false;
            const dx = dragStart.x - dragEnd.x;
            const dy = dragStart.y - dragEnd.y;
            currentShot.power = Math.min(Math.sqrt(dx*dx + dy*dy), 220) * 0.17;
            currentShot.angle = Math.atan2(dy, dx);
            if (currentShot.power > 0.8) {
                gameState = 'SETTING_SPIN';
                spinBallName.innerText = (currentPlayer === 1) ? "Bola Blanca (J1)" : "Bola Amarilla (J2)";
                spinModal.classList.remove('hidden');
            }
        };

        // Eventos de botones
        document.getElementById('start-match-btn').addEventListener('click', startGame);
        document.getElementById('reset-btn').addEventListener('click', resetToMenu);

        audioBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            const isEnabled = SoundEngine.toggle();
            audioIcon.innerHTML = isEnabled 
                ? '<path d="M6.717 3.55A.5.5 0 0 1 7 4v8a.5.5 0 0 1-.812.39L3.825 10.5H1.5A.5.5 0 0 1 1 10V6a.5.5 0 0 1 .5-.5h2.325l2.363-1.89a.5.5 0 0 1 .529-.06zM6 5.04L4.312 6.39A.5.5 0 0 1 4 6.5H2v3h2a.5.5 0 0 1 .312.11L6 10.96V5.04z"/><path d="M11.536 14.01A8.473 8.473 0 0 0 14.026 8a8.473 8.473 0 0 0-2.49-6.01l-.708.707A7.476 7.476 0 0 1 13.025 8c0 2.071-.84 3.946-2.197 5.303l.708.707z"/>'
                : '<path d="M6.717 3.55A.5.5 0 0 1 7 4v8a.5.5 0 0 1-.812.39L3.825 10.5H1.5A.5.5 0 0 1 1 10V6a.5.5 0 0 1 .5-.5h2.325l2.363-1.89a.5.5 0 0 1 .529-.06zM6 5.04L4.312 6.39A.5.5 0 0 1 4 6.5H2v3h2a.5.5 0 0 1 .312.11L6 10.96V5.04zM11.5 12.5a.5.5 0 0 1-.5-.5V4a.5.5 0 0 1 1 0v8a.5.5 0 0 1-.5.5z"/>';
        });

        canvas.addEventListener('touchstart', (e) => { e.preventDefault(); handleStart(e); }, {passive: false});
        window.addEventListener('touchmove', handleMove, {passive: false});
        window.addEventListener('touchend', handleEnd);
        canvas.addEventListener('mousedown', handleStart);
        window.addEventListener('mousemove', handleMove);
        window.addEventListener('mouseup', handleEnd);

        ballUI.addEventListener('click', (e) => {
            const r = ballUI.getBoundingClientRect();
            const x = e.clientX - r.left; const y = e.clientY - r.top;
            const nx = (x / 150) * 2 - 1; const ny = (y / 150) * 2 - 1;
            const dist = Math.sqrt(nx*nx + ny*ny);
            if (dist <= 0.95) {
                currentShot.spinX = nx; currentShot.spinY = -ny; 
                impactDot.style.left = `${x}px`; impactDot.style.top = `${y}px`;
            }
        });

        document.getElementById('shoot-btn').addEventListener('click', () => {
            spinModal.classList.add('hidden');
            gameState = 'ANIMATING';
            const cueBall = balls.find(b => b.label === (currentPlayer === 1 ? 'white' : 'yellow'));
            cueBall.vx = Math.cos(currentShot.angle) * currentShot.power;
            cueBall.vy = Math.sin(currentShot.angle) * currentShot.power;
            cueBall.spinX = currentShot.spinX; cueBall.spinY = currentShot.spinY;
            SoundEngine.playCue(Math.min(currentShot.power / 5, 1));
            stateIndicator.innerText = "Bolas en juego...";
        });

        document.getElementById('cancel-btn').addEventListener('click', () => {
            spinModal.classList.add('hidden'); gameState = 'AIMING';
        });

        window.onload = init;
        window.onresize = init;

    </script>
</body>
</html>
